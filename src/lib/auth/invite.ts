"use server";

import { nanoid } from "nanoid";
import { createClient, createAdminClient } from "@/lib/supabase/server";
import { getUser } from "./actions";
import { sendEmail } from "@/lib/email/send";
import { invitationEmailTemplate } from "@/lib/email/templates/invitation";

interface InviteData {
  email: string;
  role: "manager" | "worker";
  orgId: string;
}

export async function sendInvitation(data: InviteData) {
  const user = await getUser();
  if (!user) {
    return { error: "Nicht authentifiziert" };
  }

  const supabase = await createClient();

  // Check if user is owner or manager of the org
  const { data: membership } = await supabase
    .from("org_members")
    .select("role")
    .eq("org_id", data.orgId)
    .eq("user_id", user.id)
    .eq("status", "active")
    .single();

  if (
    !membership ||
    (membership.role !== "owner" && membership.role !== "manager")
  ) {
    return { error: "Sie haben keine Berechtigung, Mitglieder einzuladen" };
  }

  // Check if email is already a member
  const { data: existingMember } = await supabase
    .from("org_members")
    .select("id, status")
    .eq("org_id", data.orgId)
    .eq("email", data.email.toLowerCase())
    .single();

  if (existingMember) {
    if (existingMember.status === "active") {
      return {
        error: "Diese E-Mail-Adresse ist bereits Mitglied der Organisation",
      };
    }
    if (existingMember.status === "invited") {
      return {
        error: "An diese E-Mail-Adresse wurde bereits eine Einladung gesendet",
      };
    }
  }

  // Create org_member record with invited status
  // invitation_token is auto-generated by the database as UUID
  const { data: newMember, error: insertError } = await supabase
    .from("org_members")
    .insert({
      org_id: data.orgId,
      email: data.email.toLowerCase(),
      role: data.role,
      status: "invited",
    })
    .select("invitation_token")
    .single();

  if (insertError) {
    return { error: insertError.message };
  }

  // Get organization name for the email
  const { data: org } = await supabase
    .from("organizations")
    .select("name")
    .eq("id", data.orgId)
    .single();

  // Send invitation email
  const inviteUrl = `${process.env.NEXT_PUBLIC_APP_URL}/invite/${newMember?.invitation_token}`;
  const emailHtml = invitationEmailTemplate({
    orgName: org?.name || "Unbekannte Organisation",
    inviteLink: inviteUrl,
    role: data.role,
  });

  const emailResult = await sendEmail({
    to: data.email,
    subject: `Einladung zu ${org?.name || "PBQC"}`,
    html: emailHtml,
  });

  // Log email error but don't fail the invitation
  if (!emailResult.success) {
    console.error("Failed to send invitation email:", emailResult.error);
  }

  return {
    success: true,
    message: "Einladung erfolgreich gesendet",
    inviteToken: newMember?.invitation_token, // Return for testing purposes
  };
}

export async function getInvitation(token: string) {
  const supabase = await createAdminClient();

  const { data: invitation, error } = await supabase
    .from("org_members")
    .select(
      `
      *,
      organization:organizations(id, name)
    `,
    )
    .eq("invitation_token", token)
    .eq("status", "invited")
    .single();

  if (error || !invitation) {
    return { error: "Ungültige oder abgelaufene Einladung" };
  }

  return { invitation };
}

export async function acceptInvitation(token: string) {
  const user = await getUser();
  if (!user) {
    return {
      error: "Bitte melden Sie sich zuerst an oder registrieren Sie sich",
      requiresAuth: true,
    };
  }

  const supabase = await createAdminClient();

  // Get the invitation
  const { data: invitation, error: fetchError } = await supabase
    .from("org_members")
    .select("*")
    .eq("invitation_token", token)
    .eq("status", "invited")
    .single();

  if (fetchError || !invitation) {
    return { error: "Ungültige oder abgelaufene Einladung" };
  }

  // Check if email matches
  if (invitation.email.toLowerCase() !== user.email?.toLowerCase()) {
    return {
      error: "Diese Einladung wurde an eine andere E-Mail-Adresse gesendet",
    };
  }

  // Update the invitation to active
  const { error: updateError } = await supabase
    .from("org_members")
    .update({
      user_id: user.id,
      status: "active",
      joined_at: new Date().toISOString(),
      invitation_token: null,
    })
    .eq("id", invitation.id);

  if (updateError) {
    return { error: updateError.message };
  }

  return { success: true, orgId: invitation.org_id };
}

export async function resendInvitation(memberId: string, orgId: string) {
  const user = await getUser();
  if (!user) {
    return { error: "Nicht authentifiziert" };
  }

  const supabase = await createClient();

  // Check if user is owner or manager of the org
  const { data: membership } = await supabase
    .from("org_members")
    .select("role")
    .eq("org_id", orgId)
    .eq("user_id", user.id)
    .eq("status", "active")
    .single();

  if (
    !membership ||
    (membership.role !== "owner" && membership.role !== "manager")
  ) {
    return {
      error: "Sie haben keine Berechtigung, Einladungen erneut zu senden",
    };
  }

  // Get the member
  const { data: member } = await supabase
    .from("org_members")
    .select("*")
    .eq("id", memberId)
    .eq("org_id", orgId)
    .eq("status", "invited")
    .single();

  if (!member) {
    return { error: "Einladung nicht gefunden" };
  }

  // Generate new token
  const newToken = nanoid(32);

  const { error: updateError } = await supabase
    .from("org_members")
    .update({
      invitation_token: newToken,
      invited_at: new Date().toISOString(),
    })
    .eq("id", memberId);

  if (updateError) {
    return { error: updateError.message };
  }

  // Get organization name for the email
  const { data: org } = await supabase
    .from("organizations")
    .select("name")
    .eq("id", orgId)
    .single();

  // Send invitation email
  const inviteUrl = `${process.env.NEXT_PUBLIC_APP_URL}/invite/${newToken}`;
  const emailHtml = invitationEmailTemplate({
    orgName: org?.name || "Unbekannte Organisation",
    inviteLink: inviteUrl,
    role: member.role,
  });

  const emailResult = await sendEmail({
    to: member.email,
    subject: `Einladung zu ${org?.name || "PBQC"}`,
    html: emailHtml,
  });

  // Log email error but don't fail the resend
  if (!emailResult.success) {
    console.error("Failed to send invitation email:", emailResult.error);
  }

  return { success: true, message: "Einladung erneut gesendet" };
}
